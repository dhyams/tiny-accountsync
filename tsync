#!/usr/bin/env python3

import os
import zmq

# zeromq port to listen for notifications
NOTIFY_PORT = 6060

# users below 1004 are admins.  Don't bother these.  What this means is that brent
# and daniel will have to have user-logins, and not reuse these.  In the future,
# we will change dhyams to dhyamsadm and brent to brentadm.
MIN_UID = 1004
MIN_GID = 1004


def setup_zmq():
    global socket
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.connect("tcp://10.0.0.2:%d" % NOTIFY_PORT)
    socket.subscribe("")
    return socket
 

def ugname(line):
    return line.split(':')[0]

def uidorgid(line):
    return int(line.split(':')[2])

def is_regularuid(uid):
    return uid >= MIN_UID and uid != 65534

def is_regulargid(uid):
    return uid >= MIN_GID and uid != 65534

def pwhash(line):
    return line.split(':')[1]

class AccountInfo:
    def __init__(self, pwfile, shadowfile, groupfile, gshadowfile):
       with open(pwfile, 'r') as fp:
           self.pw = {ugname(x) : x for x in fp if is_regularuid(uidorgid(x))}

       with open(shadowfile, 'r') as fp:
           self.shadow = {ugname(x): x for x in fp if ugname(x) in self.pw}

       with open(groupfile, 'r') as fp:
           self.grp = {ugname(x) : x for x in fp if is_regulargid(uidorgid(x))}

       with open(gshadowfile, 'r') as fp:
           self.gshadow = {ugname(x): x for x in fp if ugname(x) in self.grp}

class FileSet:
    def __init__(self, dct):
       with open(dct["passwd"], 'r') as fp:
           self.pw = [x for x in fp if x.strip()]

       with open(dct["shadow"], 'r') as fp:
           self.shadow = [x for x in fp if x.strip()]

       with open(dct["group"], 'r') as fp:
           self.grp = [x for x in fp if x.strip()]

       with open(dct["gshadow"], 'r') as fp:
           self.gshadow = [x for x in fp if x.strip()]

    def validate(self):
         if not self.check_filesizes():
             return False

         if not self.check_for_known_users():
             return False

         if not self.check_for_known_groups():
             return False

         #if not self.check_for_sudo_users():
         #    return False

         return True

    def check_for_known_users(self):

         knowns = "root daemon bin man nobody syslog ntp sys sshd dhyams brent tsandlin slurm".split()

         for filesource in [self.pw, self.shadow]:
            users = [ugname(x) for x in filesource] 
            for k in knowns:
                if k not in users:
                    print("required username %s not in password or shadow files"%k)
                    return False

         return True

    def check_for_known_groups(self):

         knowns = "root sudo adm daemon bin man syslog ntp sys sshd dhyams brent tsandlin slurm vlock nogroup crontab".split()

         for filesource in [self.grp, self.gshadow]:
            users = [ugname(x) for x in filesource] 
            for k in knowns:
                if k not in users:
                    print("required group %s not in group or gshadow files"%k)
                    return False

         return True

    def check_filesizes(self):
         if len(self.pw) != len(self.shadow):
             print("Password file not the same length as shadow")
             return False

         if len(self.grp) != len(self.gshadow):
             print("Group file not the same length as gshadow")
             return False

         if (len(self.pw) < 20):
             print("passwd file too short.")
             return False

         if (len(self.shadow) < 20):
             print("shadow file too short.")
             return False

         if (len(self.grp) < 20):
             print("group file too short.")
             return False

         if (len(self.gshadow) < 20):
             print("gshadow file too short.")
             return False

         return True




def system(cmd):
    print("EXECUTING: "+cmd)
    return os.system(cmd)


def pull(location, suffix):
    acctfiles = "passwd group shadow gshadow".split()
    filemap = {}
    for fname in acctfiles: 
        filemap[fname] = f"/tmp/{fname}.{suffix}"
        cmd = f"rm -f {filemap[fname]}"
        system(cmd)
        cmd = f"scp {location}{fname} {filemap[fname]}"
        system(cmd)

    return filemap
     

def updatepwg(ref, oldfile, kind, isgood):

    newfile = oldfile + ".new"

    oldnames = []
    purgednames = []
    newnames = []

    with open(oldfile, "r") as fp:
        with open(newfile, "w") as fpw:
           # in-place replacement of existing users/groups
           for line in fp:
              uid = uidorgid(line) 
              name = ugname(line) 
              oldnames.append(name)
              if isgood(uid) and name not in ref:
                  print(f"Warning: {kind} {name}/{uid} in {oldfile} but not present on login-node. PURGING. ")
                  purgednames.append(name)
              else:
                  fpw.write(ref.get("name", line))
           # append any new users/groups
           for name in ref:
              if name not in oldnames:
                 uid = uidorgid(ref[name])
                 print(f"Adding new {kind} %s/%d to %s"%(name,uid,newfile))
                 newnames.append(name)
                 fpw.write(ref[name])

    return newfile,newnames,purgednames


def updateshadow(shadowref, oldfile, newusers, purgedusers):
    newfile = oldfile + ".new"

    oldnames = []

    with open(oldfile, "r") as fp:
        with open(newfile, "w") as fpw:
           for line in fp:
              name = ugname(line)
              oldnames.append(name)
              if name in purgedusers:
                  print(f"Warning: {name} in {oldfile} but not present on login-node. PURGING. ")
              else:
                  fpw.write(shadowref.get("name", line))
           for name in newusers:
               if name not in shadowref:
                   print(f"Error: {name} was a newly added user but has no shadow entry.")
               else:
                   print(f"Adding new username {name} to shadow.")
                   fpw.write(shadowref[name])

    return newfile


def check_fileset(fileset):
    try:
        fs = FileSet(fileset)
        return fs.validate()

    except:
        import traceback
        traceback.print_exc()
        print("Unknown error in check_fileset")
        return False


def process():

    #return # safety hatch

    # pull from the login node.  This is the reference data.
    ref = pull("login-node:/etc/", "login-node")

    # check to see if the appropriate files exist. 
     
    acct = AccountInfo(ref["passwd"], ref["shadow"], ref["group"], ref["gshadow"])

    # iterate through the machines that we want to eventually push to, and pull shadow, passwd,
    # and group from them [storage-node, management-node:/nfsroot]

    ###########################
    # storage node
    ###########################
    old_sn_files = pull("storage-node:/etc/", "sn")

    newpwfile, newusers, purgedusers = updatepwg(acct.pw, old_sn_files["passwd"],"username", is_regularuid) 
    newshadowfile = updateshadow(acct.shadow, old_sn_files["shadow"], newusers, purgedusers)

    newgrpfile, newgrps, purgedgrps = updatepwg(acct.grp, old_sn_files["group"], "group", is_regulargid)
    newgshadowfile = updateshadow(acct.gshadow, old_sn_files["gshadow"], newgrps, purgedgrps)

    new_storage_node_files = { "passwd": newpwfile, "group": newgrpfile, "shadow": newshadowfile, "gshadow": newgshadowfile }



    ###########################
    # nfsroot 
    ###########################
    if 0:
     old_nfsroot_files = pull("management-node:/nfsroot/etc/", "nfsroot")

     newpwfile, newusers, purgedusers = updatepwg(acct.pw, old_nfsroot_files["passwd"],"username", is_regularuid) 
     newshadowfile = updateshadow(acct.shadow, old_nfsroot_files["shadow"], newusers, purgedusers)

     newgrpfile, newgrps, purgedgrps = updatepwg(acct.grp, old_nfsroot_files["group"], "group", is_regulargid)
     newgshadowfile = updateshadow(acct.gshadow, old_nfsroot_files["gshadow"], newgrps, purgedgrps)

     new_nfsroot_files = { "passwd": newpwfile, "group": newgrpfile, "shadow": newshadowfile, "gshadow": newgshadowfile }
     
    # do sanity checks

    if check_fileset(new_storage_node_files) and check_fileset(new_nfsroot_files):
        # push
        pass

    # TODO
    # every push needs a backup command first!!
    # maybe execute a git add then commit?
    # push files from storage-node back to storage-node

    # push files from management-node/nfsroot back to nfsroot
    # push files from management-node/nfsroot to c[1-14]: use pdcp!

  

if __name__ == "__main__":
    
    if 0:
        socket = setup_zmq()
        while True:
            notify = socket.recv_string()
            print(notify)
            process()
    else:
         process()
